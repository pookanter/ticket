// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tickets.sql

package db

import (
	"context"
	"database/sql"

	"github.com/guregu/null"
)

const countTicketByStatusID = `-- name: CountTicketByStatusID :one
SELECT
  COUNT(*)
FROM
  tickets
WHERE
  status_id = ?
`

func (q *Queries) CountTicketByStatusID(ctx context.Context, statusID uint32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTicketByStatusID, statusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTicket = `-- name: CreateTicket :exec
INSERT INTO
  tickets (
    status_id,
    title,
    description,
    contact,
    sort_order,
    created_at
  )
VALUES
  (?, ?, ?, ?, ?, NOW())
`

type CreateTicketParams struct {
	StatusID    uint32      `db:"status_id" json:"status_id"`
	Title       null.String `db:"title" json:"title"`
	Description null.String `db:"description" json:"description"`
	Contact     null.String `db:"contact" json:"contact"`
	SortOrder   uint32      `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) error {
	_, err := q.db.ExecContext(ctx, createTicket,
		arg.StatusID,
		arg.Title,
		arg.Description,
		arg.Contact,
		arg.SortOrder,
	)
	return err
}

const getLastInsertTicketByStatusID = `-- name: GetLastInsertTicketByStatusID :one
SELECT
  id, status_id, title, description, contact, sort_order, created_at, updated_at
FROM
  tickets
WHERE
  tickets.status_id = ?
  AND id = (
    SELECT
      LAST_INSERT_ID()
    FROM
      tickets AS t
    LIMIT
      1
  )
`

func (q *Queries) GetLastInsertTicketByStatusID(ctx context.Context, statusID uint32) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getLastInsertTicketByStatusID, statusID)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.StatusID,
		&i.Title,
		&i.Description,
		&i.Contact,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicket = `-- name: GetTicket :one
SELECT
  tickets.id, tickets.status_id, tickets.title, tickets.description, tickets.contact, tickets.sort_order, tickets.created_at, tickets.updated_at
FROM
  tickets
  JOIN statuses ON tickets.status_id = statuses.id
  JOIN boards ON statuses.board_id = boards.id
WHERE
  tickets.id = ?
  AND tickets.status_id = coalesce(?, tickets.status_id)
  AND statuses.board_id = coalesce(?, statuses.board_id)
  AND boards.user_id = coalesce(?, boards.user_id)
`

type GetTicketParams struct {
	ID       uint64        `db:"id" json:"id"`
	StatusID sql.NullInt32 `db:"status_id" json:"status_id"`
	BoardID  sql.NullInt32 `db:"board_id" json:"board_id"`
	UserID   sql.NullInt64 `db:"user_id" json:"user_id"`
}

func (q *Queries) GetTicket(ctx context.Context, arg GetTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicket,
		arg.ID,
		arg.StatusID,
		arg.BoardID,
		arg.UserID,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.StatusID,
		&i.Title,
		&i.Description,
		&i.Contact,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketsByStatusID = `-- name: GetTicketsByStatusID :many
SELECT
  id, status_id, title, description, contact, sort_order, created_at, updated_at
FROM
  tickets
WHERE
  status_id = ?
ORDER BY
  sort_order ASC
`

func (q *Queries) GetTicketsByStatusID(ctx context.Context, statusID uint32) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, getTicketsByStatusID, statusID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.StatusID,
			&i.Title,
			&i.Description,
			&i.Contact,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketsWithMinimumSortOrder = `-- name: GetTicketsWithMinimumSortOrder :many
SELECT
  id, status_id, title, description, contact, sort_order, created_at, updated_at
FROM
  tickets
WHERE
  status_id = ?
  AND sort_order >= ?
ORDER BY
  (
    CASE
      WHEN ? = 'asc' THEN sort_order
    END
  ) ASC,
  (
    CASE
      WHEN ? = 'desc' THEN sort_order
    END
  ) DESC
`

type GetTicketsWithMinimumSortOrderParams struct {
	StatusID           uint32      `db:"status_id" json:"status_id"`
	SortOrder          uint32      `db:"sort_order" json:"sort_order"`
	SortOrderDirection interface{} `db:"sort_order_direction" json:"sort_order_direction"`
}

func (q *Queries) GetTicketsWithMinimumSortOrder(ctx context.Context, arg GetTicketsWithMinimumSortOrderParams) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, getTicketsWithMinimumSortOrder,
		arg.StatusID,
		arg.SortOrder,
		arg.SortOrderDirection,
		arg.SortOrderDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.StatusID,
			&i.Title,
			&i.Description,
			&i.Contact,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :exec
UPDATE
  tickets
SET
  status_id = ?,
  title = ?,
  description = ?,
  contact = ?,
  sort_order = ?,
  updated_at = NOW()
WHERE
  id = ?
`

type UpdateTicketParams struct {
	StatusID    uint32      `db:"status_id" json:"status_id"`
	Title       null.String `db:"title" json:"title"`
	Description null.String `db:"description" json:"description"`
	Contact     null.String `db:"contact" json:"contact"`
	SortOrder   uint32      `db:"sort_order" json:"sort_order"`
	ID          uint64      `db:"id" json:"id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) error {
	_, err := q.db.ExecContext(ctx, updateTicket,
		arg.StatusID,
		arg.Title,
		arg.Description,
		arg.Contact,
		arg.SortOrder,
		arg.ID,
	)
	return err
}

const updateTicketSortOrder = `-- name: UpdateTicketSortOrder :exec
UPDATE
  tickets
SET
  sort_order = ?
WHERE
  id = ?
`

type UpdateTicketSortOrderParams struct {
	SortOrder uint32 `db:"sort_order" json:"sort_order"`
	ID        uint64 `db:"id" json:"id"`
}

func (q *Queries) UpdateTicketSortOrder(ctx context.Context, arg UpdateTicketSortOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateTicketSortOrder, arg.SortOrder, arg.ID)
	return err
}
