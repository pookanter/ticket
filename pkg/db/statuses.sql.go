// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: statuses.sql

package db

import (
	"context"
	"database/sql"
	"strings"

	null "github.com/guregu/null/v5"
)

const countStatusByBoardID = `-- name: CountStatusByBoardID :one
SELECT
  COUNT(*)
FROM
  statuses
WHERE
  board_id = ?
`

func (q *Queries) CountStatusByBoardID(ctx context.Context, boardID uint32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStatusByBoardID, boardID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStatusWithBoard = `-- name: CountStatusWithBoard :one
SELECT
  COUNT(statuses.id)
FROM
  statuses
  JOIN boards ON statuses.board_id = boards.id
WHERE
  statuses.id IN (/*SLICE:ids*/?)
  AND statuses.board_id = ?
  AND boards.user_id = ?
`

type CountStatusWithBoardParams struct {
	Ids     []uint32 `db:"ids" json:"ids"`
	BoardID uint32   `db:"board_id" json:"board_id"`
	UserID  uint64   `db:"user_id" json:"user_id"`
}

func (q *Queries) CountStatusWithBoard(ctx context.Context, arg CountStatusWithBoardParams) (int64, error) {
	query := countStatusWithBoard
	var queryParams []interface{}
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.BoardID)
	queryParams = append(queryParams, arg.UserID)
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStatusWithBoardExclude = `-- name: CountStatusWithBoardExclude :one
SELECT
  COUNT(statuses.id)
FROM
  statuses
  JOIN boards ON statuses.board_id = boards.id
WHERE
  statuses.id NOT IN (/*SLICE:ids*/?)
  AND statuses.board_id = ?
  AND boards.user_id = ?
`

type CountStatusWithBoardExcludeParams struct {
	Ids     []uint32 `db:"ids" json:"ids"`
	BoardID uint32   `db:"board_id" json:"board_id"`
	UserID  uint64   `db:"user_id" json:"user_id"`
}

func (q *Queries) CountStatusWithBoardExclude(ctx context.Context, arg CountStatusWithBoardExcludeParams) (int64, error) {
	query := countStatusWithBoardExclude
	var queryParams []interface{}
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.BoardID)
	queryParams = append(queryParams, arg.UserID)
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStatus = `-- name: CreateStatus :exec
INSERT INTO
  statuses (board_id, title, sort_order, created_at)
VALUES
  (?, ?, ?, NOW())
`

type CreateStatusParams struct {
	BoardID   uint32      `db:"board_id" json:"board_id"`
	Title     null.String `db:"title" json:"title"`
	SortOrder uint32      `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateStatus(ctx context.Context, arg CreateStatusParams) error {
	_, err := q.db.ExecContext(ctx, createStatus, arg.BoardID, arg.Title, arg.SortOrder)
	return err
}

const deleteStatus = `-- name: DeleteStatus :exec
DELETE FROM
  statuses
WHERE
  id = ?
`

func (q *Queries) DeleteStatus(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteStatus, id)
	return err
}

const getLastInsertStatus = `-- name: GetLastInsertStatus :one
SELECT
  id, board_id, title, sort_order, created_at, updated_at
FROM
  statuses
WHERE
  id = (
    SELECT
      LAST_INSERT_ID()
    FROM
      statuses AS s
    LIMIT
      1
  )
`

func (q *Queries) GetLastInsertStatus(ctx context.Context) (Status, error) {
	row := q.db.QueryRowContext(ctx, getLastInsertStatus)
	var i Status
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Title,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStatus = `-- name: GetStatus :one
SELECT
  id, board_id, title, sort_order, created_at, updated_at
FROM
  statuses
WHERE
  id = coalesce(?, id)
  AND board_id = coalesce(?, board_id)
`

type GetStatusParams struct {
	ID      sql.NullInt32 `db:"id" json:"id"`
	BoardID sql.NullInt32 `db:"board_id" json:"board_id"`
}

func (q *Queries) GetStatus(ctx context.Context, arg GetStatusParams) (Status, error) {
	row := q.db.QueryRowContext(ctx, getStatus, arg.ID, arg.BoardID)
	var i Status
	err := row.Scan(
		&i.ID,
		&i.BoardID,
		&i.Title,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStatusWithBoard = `-- name: GetStatusWithBoard :one
SELECT
  statuses.id, statuses.board_id, statuses.title, statuses.sort_order, statuses.created_at, statuses.updated_at,
  boards.id, boards.user_id, boards.title, boards.sort_order, boards.created_at, boards.updated_at
FROM
  statuses
  JOIN boards ON statuses.board_id = boards.id
WHERE
  statuses.id = ?
  AND statuses.board_id = ?
  AND boards.user_id = ?
`

type GetStatusWithBoardParams struct {
	ID      uint32 `db:"id" json:"id"`
	BoardID uint32 `db:"board_id" json:"board_id"`
	UserID  uint64 `db:"user_id" json:"user_id"`
}

type GetStatusWithBoardRow struct {
	Status Status `db:"status" json:"status"`
	Board  Board  `db:"board" json:"board"`
}

func (q *Queries) GetStatusWithBoard(ctx context.Context, arg GetStatusWithBoardParams) (GetStatusWithBoardRow, error) {
	row := q.db.QueryRowContext(ctx, getStatusWithBoard, arg.ID, arg.BoardID, arg.UserID)
	var i GetStatusWithBoardRow
	err := row.Scan(
		&i.Status.ID,
		&i.Status.BoardID,
		&i.Status.Title,
		&i.Status.SortOrder,
		&i.Status.CreatedAt,
		&i.Status.UpdatedAt,
		&i.Board.ID,
		&i.Board.UserID,
		&i.Board.Title,
		&i.Board.SortOrder,
		&i.Board.CreatedAt,
		&i.Board.UpdatedAt,
	)
	return i, err
}

const getStatuses = `-- name: GetStatuses :many
SELECT
  id, board_id, title, sort_order, created_at, updated_at
FROM
  statuses
WHERE
  board_id = coalesce(?, board_id)
  AND (
    id = coalesce(/*SLICE:ids*/?, id)
    OR id IN (/*SLICE:ids*/?)
  )
ORDER BY
  board_id ASC,
  (
    CASE
      WHEN ? = 'asc' THEN sort_order
    END
  ) ASC,
  (
    CASE
      WHEN ? = 'desc' THEN sort_order
    END
  ) DESC
`

type GetStatusesParams struct {
	BoardID            sql.NullInt32 `db:"board_id" json:"board_id"`
	Ids                []uint32      `db:"ids" json:"ids"`
	SortOrderDirection interface{}   `db:"sort_order_direction" json:"sort_order_direction"`
}

func (q *Queries) GetStatuses(ctx context.Context, arg GetStatusesParams) ([]Status, error) {
	query := getStatuses
	var queryParams []interface{}
	queryParams = append(queryParams, arg.BoardID)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.SortOrderDirection)
	queryParams = append(queryParams, arg.SortOrderDirection)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Status{}
	for rows.Next() {
		var i Status
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Title,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusesWithBoard = `-- name: GetStatusesWithBoard :many
SELECT
  statuses.id, statuses.board_id, statuses.title, statuses.sort_order, statuses.created_at, statuses.updated_at,
  boards.id, boards.user_id, boards.title, boards.sort_order, boards.created_at, boards.updated_at
FROM
  statuses
  JOIN boards ON statuses.board_id = boards.id
WHERE
  statuses.board_id = ?
  AND boards.user_id = ?
`

type GetStatusesWithBoardParams struct {
	BoardID uint32 `db:"board_id" json:"board_id"`
	UserID  uint64 `db:"user_id" json:"user_id"`
}

type GetStatusesWithBoardRow struct {
	Status Status `db:"status" json:"status"`
	Board  Board  `db:"board" json:"board"`
}

func (q *Queries) GetStatusesWithBoard(ctx context.Context, arg GetStatusesWithBoardParams) ([]GetStatusesWithBoardRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatusesWithBoard, arg.BoardID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStatusesWithBoardRow{}
	for rows.Next() {
		var i GetStatusesWithBoardRow
		if err := rows.Scan(
			&i.Status.ID,
			&i.Status.BoardID,
			&i.Status.Title,
			&i.Status.SortOrder,
			&i.Status.CreatedAt,
			&i.Status.UpdatedAt,
			&i.Board.ID,
			&i.Board.UserID,
			&i.Board.Title,
			&i.Board.SortOrder,
			&i.Board.CreatedAt,
			&i.Board.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusesWithMinimumSortOrder = `-- name: GetStatusesWithMinimumSortOrder :many
SELECT
  id, board_id, title, sort_order, created_at, updated_at
FROM
  statuses
WHERE
  board_id = ?
  AND sort_order >= ?
ORDER BY
  (
    CASE
      WHEN ? = 'asc' THEN sort_order
    END
  ) ASC,
  (
    CASE
      WHEN ? = 'desc' THEN sort_order
    END
  ) DESC
`

type GetStatusesWithMinimumSortOrderParams struct {
	BoardID            uint32      `db:"board_id" json:"board_id"`
	SortOrder          uint32      `db:"sort_order" json:"sort_order"`
	SortOrderDirection interface{} `db:"sort_order_direction" json:"sort_order_direction"`
}

func (q *Queries) GetStatusesWithMinimumSortOrder(ctx context.Context, arg GetStatusesWithMinimumSortOrderParams) ([]Status, error) {
	rows, err := q.db.QueryContext(ctx, getStatusesWithMinimumSortOrder,
		arg.BoardID,
		arg.SortOrder,
		arg.SortOrderDirection,
		arg.SortOrderDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Status{}
	for rows.Next() {
		var i Status
		if err := rows.Scan(
			&i.ID,
			&i.BoardID,
			&i.Title,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatus = `-- name: UpdateStatus :exec
UPDATE
  statuses
SET
  title = ?,
  sort_order = ?,
  updated_at = NOW()
WHERE
  id = ?
`

type UpdateStatusParams struct {
	Title     null.String `db:"title" json:"title"`
	SortOrder uint32      `db:"sort_order" json:"sort_order"`
	ID        uint32      `db:"id" json:"id"`
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateStatus, arg.Title, arg.SortOrder, arg.ID)
	return err
}

const updateStatusSortOrder = `-- name: UpdateStatusSortOrder :exec
UPDATE
  statuses
SET
  sort_order = ?
WHERE
  id = ?
`

type UpdateStatusSortOrderParams struct {
	SortOrder uint32 `db:"sort_order" json:"sort_order"`
	ID        uint32 `db:"id" json:"id"`
}

func (q *Queries) UpdateStatusSortOrder(ctx context.Context, arg UpdateStatusSortOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateStatusSortOrder, arg.SortOrder, arg.ID)
	return err
}
